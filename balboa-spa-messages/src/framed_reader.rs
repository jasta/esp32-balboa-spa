use std::io;
use std::io::{BufReader, Read};
use log::debug;
use crate::frame_decoder::FrameDecoder;
use crate::message::Message;

#[derive(Debug)]
pub struct FramedReader<R> {
  buf_reader: BufReader<R>,
  framed_reader: FrameDecoder,
  debug_bytes: bool,
}

impl<R: Read> FramedReader<R> {
  pub fn new(raw_reader: R) -> Self {
    Self {
      buf_reader: BufReader::with_capacity(32, raw_reader),
      framed_reader: FrameDecoder::new(),
      debug_bytes: false,
    }
  }

  pub fn set_debug_bytes(mut self, enable: bool) -> Self {
    self.debug_bytes = enable;
    self
  }

  pub fn next_message(&mut self) -> io::Result<Message> {
    let mut buf = [0u8; 1];
    loop {
      self.buf_reader.read_exact(&mut buf)?;
      let byte = buf[0];
      if self.debug_bytes {
        debug!("Got {byte:02X}");
      }
      if let Some(message) = self.framed_reader.accept(byte) {
        return Ok(message);
      }
    }
  }
}

impl <R: Read> Iterator for FramedReader<R> {
  type Item = Message;

  fn next(&mut self) -> Option<Self::Item> {
    self.next_message().ok()
  }
}

#[cfg(test)]
mod tests {
  use std::io::Cursor;
  use log::LevelFilter;
  use super::*;

  #[test]
  fn test_many_packets() {
    let _ = env_logger::builder().filter_level(LevelFilter::Trace).is_test(true).try_init();

    let encoded = [
      0x7E,
      0x05, 0xFE, 0xBF, 0x00, 0xAC, 0x7E, 0x7E, 0x1B, 0xFF, 0xAF,
      0x13, 0x00, 0x00, 0x28, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x1C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x4F, 0x00, 0xC2, 0x7E, 0x7E, 0x05, 0xFE, 0xBF, 0x00,
      0xAC, 0x7E, 0x7E, 0x1B, 0xFF, 0xAF, 0x13, 0x00, 0x00, 0x28,
      0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1C, 0x01, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x00, 0xC2,
      0x7E, 0x7E, 0x05, 0xFE, 0xBF, 0x00, 0xAC, 0x7E, 0x7E, 0x1B,
      0xFF, 0xAF, 0x13, 0x00, 0x00, 0x28, 0x00, 0x0A, 0x00, 0x00,
      0x00, 0x00, 0x01, 0x1C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x4F, 0x00, 0xC2, 0x7E, 0x7E, 0x05, 0xFE,
      0xBF, 0x00, 0xAC, 0x7E, 0x7E, 0x1B, 0xFF, 0xAF, 0x13, 0x00,
      0x00, 0x28, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1C,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F,
      0x00, 0xC2, 0x7E, 0x7E, 0x05, 0xFE, 0xBF, 0x00, 0xAC, 0x7E,
      0x7E, 0x1B, 0xFF, 0xAF, 0x13, 0x00, 0x00, 0x28, 0x00, 0x0A,
      0x00, 0x00, 0x00, 0x00, 0x01, 0x1C, 0x01, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x00, 0xC2, 0x7E, 0x7E,
      0x05, 0xFE, 0xBF, 0x00, 0xAC, 0x7E, 0x7E, 0x1B, 0xFF, 0xAF,
      0x13, 0x00, 0x00, 0x28, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x1C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x4F, 0x00, 0xC2, 0x7E
    ];
    let expected_types = vec![
      0x0, 0x13,
      0x0, 0x13,
      0x0, 0x13,
      0x0, 0x13,
      0x0, 0x13,
      0x0, 0x13,
    ];

    let cursor = Cursor::new(encoded);
    let reader = FramedReader::new(cursor);
    let messages: Vec<_> = reader.collect();

    assert_eq!(messages.len(), 12);

    let got_types: Vec<_> = messages.iter()
        .map(|m| m.message_type)
        .collect();
    assert_eq!(got_types, expected_types);
  }
}
